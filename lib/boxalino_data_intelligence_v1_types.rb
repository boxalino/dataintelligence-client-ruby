#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module DataIntelligenceServiceExceptionNumber
  # general case of exception (no special detailed provided)
  GENERAL_EXCEPTION = 1
  # the provided credentials to retrieve an authentication token are not valid (wrong username, password or both)
  INVALID_CREDENTIALS = 2
  # your user has been blocked (but it doesn't necessarily mean your account has been blocked)
  BLOCKED_USER = 3
  # your account has been blocked, you must contact Boxalino (<a href="mailto:support@boxalino.com">support@boxalino.com</a>) to know the reasons of this blocking.
  BLOCKED_ACCOUNT = 4
  # the provided authentication token is invalid (wrong, or no more valid), you should get a new one by calling the GetAuthentication service.
  INVALID_AUTHENTICATION_TOKEN = 5
  # specific to the service function UpdatePassword: means that the new password is not correct (should be at least 8 characters long and not contain any punctuation)
  INVALID_NEW_PASSWORD = 6
  # the provided configuration object contains a configuration version number which doesn't exists or cannot be accessed
  INVALID_CONFIGURATION_VERSION = 7
  # the provided XML data source is not correct (see documentation of the data source XML format)
  INVALID_DATASOURCE = 8
  # the provided content to be changed (updated, deleted, etc.) is defined with a content id which doesn't exists
  NON_EXISTING_CONTENT_ID = 9
  # the provided content id to be created already exists
  ALREADY_EXISTING_CONTENT_ID = 10
  # the provided content id doesn't not match the requested format (less than 50 alphanumeric characters without any punctuation or accent)
  INVALID_CONTENT_ID = 11
  # the provided content data are not correctly set
  INVALID_CONTENT = 12
  # one of the provided languages has not been defined for this account
  INVALID_LANGUAGE = 13
  # the provided file identifier has been already used
  DUPLICATED_FILE_ID = 14
  # the provided list of columns is empty
  EMPTY_COLUMNS_LIST = 15
  # the provided file identifier was not found
  NON_EXISTING_FILE = 16
  # the provided time range is incorrect (start timestamp is higher than the end one)
  INVALID_RANGE = 17
  # the provided report request contains some invalid parameters settings (missing settings, conflicting settings, etc.)
  INVALID_REPORT_REQUEST = 18
  VALUE_MAP = {1 => "GENERAL_EXCEPTION", 2 => "INVALID_CREDENTIALS", 3 => "BLOCKED_USER", 4 => "BLOCKED_ACCOUNT", 5 => "INVALID_AUTHENTICATION_TOKEN", 6 => "INVALID_NEW_PASSWORD", 7 => "INVALID_CONFIGURATION_VERSION", 8 => "INVALID_DATASOURCE", 9 => "NON_EXISTING_CONTENT_ID", 10 => "ALREADY_EXISTING_CONTENT_ID", 11 => "INVALID_CONTENT_ID", 12 => "INVALID_CONTENT", 13 => "INVALID_LANGUAGE", 14 => "DUPLICATED_FILE_ID", 15 => "EMPTY_COLUMNS_LIST", 16 => "NON_EXISTING_FILE", 17 => "INVALID_RANGE", 18 => "INVALID_REPORT_REQUEST"}
  VALID_VALUES = Set.new([GENERAL_EXCEPTION, INVALID_CREDENTIALS, BLOCKED_USER, BLOCKED_ACCOUNT, INVALID_AUTHENTICATION_TOKEN, INVALID_NEW_PASSWORD, INVALID_CONFIGURATION_VERSION, INVALID_DATASOURCE, NON_EXISTING_CONTENT_ID, ALREADY_EXISTING_CONTENT_ID, INVALID_CONTENT_ID, INVALID_CONTENT, INVALID_LANGUAGE, DUPLICATED_FILE_ID, EMPTY_COLUMNS_LIST, NON_EXISTING_FILE, INVALID_RANGE, INVALID_REPORT_REQUEST]).freeze
end

module ConfigurationVersionType
  # this is the normal case, as you want to retrieve the current dev version of your account configuration and not touch the production one
  CURRENT_DEVELOPMENT_VERSION = 1
  # this should only be used in rare cases where you want to recuperate information from the production configuration, but be careful in changing this version as it will immediately affect your production processes!
  CURRENT_PRODUCTION_VERSION = 2
  VALUE_MAP = {1 => "CURRENT_DEVELOPMENT_VERSION", 2 => "CURRENT_PRODUCTION_VERSION"}
  VALID_VALUES = Set.new([CURRENT_DEVELOPMENT_VERSION, CURRENT_PRODUCTION_VERSION]).freeze
end

module Language
  GERMAN = 1
  FRENCH = 2
  ENGLISH = 3
  ITALIAN = 4
  SPANISH = 5
  DUTCH = 6
  PORTUGUESE = 7
  SWEDISH = 8
  ARABIC = 9
  RUSSIAN = 10
  JAPANESE = 11
  KOREAN = 12
  TURKISH = 13
  VIETNAMESE = 14
  POLISH = 15
  UKRAINIAN = 16
  CHINESE_MANDARIN = 17
  OTHER = 100
  VALUE_MAP = {1 => "GERMAN", 2 => "FRENCH", 3 => "ENGLISH", 4 => "ITALIAN", 5 => "SPANISH", 6 => "DUTCH", 7 => "PORTUGUESE", 8 => "SWEDISH", 9 => "ARABIC", 10 => "RUSSIAN", 11 => "JAPANESE", 12 => "KOREAN", 13 => "TURKISH", 14 => "VIETNAMESE", 15 => "POLISH", 16 => "UKRAINIAN", 17 => "CHINESE_MANDARIN", 100 => "OTHER"}
  VALID_VALUES = Set.new([GERMAN, FRENCH, ENGLISH, ITALIAN, SPANISH, DUTCH, PORTUGUESE, SWEDISH, ARABIC, RUSSIAN, JAPANESE, KOREAN, TURKISH, VIETNAMESE, POLISH, UKRAINIAN, CHINESE_MANDARIN, OTHER]).freeze
end

module ProcessTaskExecutionStatusType
  # The process was not started yet
  WAITING = 1
  # The process has started and is currently running
  STARTED = 2
  # The process has finished successfully
  FINISHED_SUCCESS = 3
  # The process has finished, but with some warnings
  FINISHED_WITH_WARNINGS = 4
  # The process has failed
  FAILED = 5
  # The process has been aborted
  ABORTED = 6
  VALUE_MAP = {1 => "WAITING", 2 => "STARTED", 3 => "FINISHED_SUCCESS", 4 => "FINISHED_WITH_WARNINGS", 5 => "FAILED", 6 => "ABORTED"}
  VALID_VALUES = Set.new([WAITING, STARTED, FINISHED_SUCCESS, FINISHED_WITH_WARNINGS, FAILED, ABORTED]).freeze
end

module CSVFileColumnType
  # text string encoded using UTF-8 encoding
  STRING = 1
  # signed 64-bit integer
  INTEGER = 2
  # floating point number
  DOUBLE = 3
  # textual representation of the date and time in the format YYYY-MM-DD HH:MM:SS
  DATETIME = 4
  # textual representation of the date in the format YYYY-MM-DD
  DATE = 5
  # textual representation of the time in the format HH:MM:SS
  TIME = 6
  # numerical representation of the date and time as an unsigned 32-bit integer, counting the seconds since the start of the UNIX epoch
  UNIX_TIMESTAMP = 7
  VALUE_MAP = {1 => "STRING", 2 => "INTEGER", 3 => "DOUBLE", 4 => "DATETIME", 5 => "DATE", 6 => "TIME", 7 => "UNIX_TIMESTAMP"}
  VALID_VALUES = Set.new([STRING, INTEGER, DOUBLE, DATETIME, DATE, TIME, UNIX_TIMESTAMP]).freeze
end

module TimeRangePrecision
  # daily precision
  DAY = 1
  # weekly precision
  WEEK = 2
  # monthly precision
  MONTH = 3
  # quarterly precision
  QUARTER = 4
  # yearly precision
  YEAR = 5
  # return all data for provided date range as one
  ALL = 6
  VALUE_MAP = {1 => "DAY", 2 => "WEEK", 3 => "MONTH", 4 => "QUARTER", 5 => "YEAR", 6 => "ALL"}
  VALID_VALUES = Set.new([DAY, WEEK, MONTH, QUARTER, YEAR, ALL]).freeze
end

module ReportMetricType
  # number of unique visitors (or user)
  VISITORS = 1
  # number of visits (or session)
  VISITS = 2
  # number of landing page bounces
  BOUNCES = 3
  # BOUNCES / VISITS
  BOUNCE_RATE = 4
  # number of page views
  PAGE_VIEWS = 5
  # PAGE_VIEWS / VISITS
  PAGE_VIEWS_PER_VISIT = 6
  # total time on site in secods
  TIME_ON_SITE = 31
  # TIME_ON_SITE / VISITS
  AVERAGE_TIME_ON_SITE = 7
  # number of product views
  PRODUCT_VIEWS = 8
  # PRODUCT_VIEWS / VISITS
  PRODUCT_VIEWS_PER_VISIT = 9
  # number of visits having at least one product view
  VISITS_WITH_PRODUCT_VIEWS = 10
  # VISITS_WITH_PRODUCT_VIEWS / VISITS
  VISITS_WITH_PRODUCT_VIEWS_RATE = 11
  # number of in-site searches
  SEARCHES = 12
  # SEARCHES / VISITS
  SEARCHES_PER_VISIT = 13
  # number of visits having at least one search
  VISITS_WITH_SEARCHES = 14
  # VISITS_WITH_SEARCHES / VISITS
  VISITS_WITH_SEARCHES_RATE = 15
  # number of goals (require identifier to be provided with the choice identifier)
  GOALS = 16
  # GOALS / VISITS (require identifier to be provided with the choice identifier)
  GOALS_PER_VISIT = 17
  # number of visits having at least one goal (require identifier to be provided with the choice identifier)
  VISITS_WITH_GOALS = 18
  # VISITS_WITH_GOALS / VISITS (require identifier to be provided with the choice identifier)
  VISITS_WITH_GOALS_RATE = 19
  # number of transactions
  TRANSACTIONS = 20
  # TRANSACTIONS / VISITS
  TRANSACTIONS_PER_VISIT = 21
  # number of visits having at least one transaction
  VISITS_WITH_TRANSACTIONS = 22
  # VISITS_WITH_TRANSACTIONS / VISITS
  VISITS_WITH_TRANSACTIONS_RATE = 23
  # transaction turnover
# N.B.: will return zero for all cases which cannot be mapped to any transaction
  TRANSACTIONS_TURNOVER = 28
  # sum of the transaction parameter values (require identifier to be provided with the transaction parameter name)
# N.B.: will return zero for all cases which cannot be mapped to any transaction
  TRANSACTIONS_PARAMETER_SUM = 29
  # count of the total number of transaction items (one product with quantity one is one item)
  TRANSACTIONS_QUANTITY = 30
  # number of add-to-basket events
  ADD_TO_BASKETS = 24
  # ADD_TO_BASKET / VISITS
  ADD_TO_BASKETS_PER_VISIT = 25
  # number of visits having at least one add to basket event
  VISITS_WITH_ADD_TO_BASKETS = 26
  # VISITS_WITH_ADD_TO_BASKETS / VISITS
  VISITS_WITH_ADD_TO_BASKETS_RATE = 27
  # number of time the event has occurred
  EVENT_COUNT = 40
  # number of e-mails sent
  MAIL_SENT = 50
  # number of e-mails opened
  MAIL_OPENED = 51
  # number of e-mails clicked
  MAIL_CLICKED = 52
  # number of display of a choice
  CHOICE_DISPLAYS = 100
  # number of visits having at least one choice display
  VISITS_WITH_CHOICE_DISPLAYS = 101
  # number of product views event related to product displayed in a choice display
# if a ReportDimension is on the product id, then only for this product id
  PRODUCT_VIEWS_FROM_CHOICE_DISPLAY = 110
  # number of visits having at least one product views event related to product displayed in a choice display
# if a ReportDimension is on the product id, then only for this product id
# if a ReportDimension is on a Choice, then only for this choice
# if a ReportDimension is on a ChoiceVariant, then only for this choice variant
  VISITS_WITH_PRODUCT_VIEWS_FROM_CHOICE_DISPLAY = 111
  # number of transactions related to product displayed in a choice display
# if a ReportDimension is on the product id, then only for this product id
# if a ReportDimension is on a Choice, then only for this choice
# if a ReportDimension is on a ChoiceVariant, then only for this choice variant
  TRANSACTIONS_FROM_CHOICE_DISPLAY = 112
  # sum of transaction property value of transactions related to product displayed in a choice display
# if a ReportDimension is on the product id, then only for this product id
# if a ReportDimension is on a Choice, then only for this choice
# if a ReportDimension is on a ChoiceVariant, then only for this choice variant
  TRANSACTIONS_PARAMETER_SUM_FROM_CHOICE_DISPLAY = 113
  # number of visits having at least one transaction event related to product displayed in a choice display
# if a ReportDimension is on the product id, then only for this product id
# if a ReportDimension is on a Choice, then only for this choice
# if a ReportDimension is on a ChoiceVariant, then only for this choice variant
  VISITS_WITH_TRANSACTIONS_FROM_CHOICE_DISPLAY = 114
  # number of add to baskets related to product displayed in a choice display
# if a ReportDimension is on the product id, then only for this product id
# if a ReportDimension is on a Choice, then only for this choice
# if a ReportDimension is on a ChoiceVariant, then only for this choice variant
  ADD_TO_BASKETS_FROM_CHOICE_DISPLAY = 115
  # number of visits having at least one add to basket related to product displayed in a choice display
# if a ReportDimension is on the product id, then only for this product id
# if a ReportDimension is on a Choice, then only for this choice
# if a ReportDimension is on a ChoiceVariant, then only for this choice variant
  VISITS_WITH_ADD_TO_BASKETS_FROM_CHOICE_DISPLAY = 116
  # number of goals related to product displayed in a choice display
# (require identifier to be provided with the choice identifier)
# (will only work if a product identifier is provided with the goal)
# if a ReportDimension is on the product id, then only for this product id
# if a ReportDimension is on a Choice, then only for this choice
# if a ReportDimension is on a ChoiceVariant, then only for this choice variant
  GOALS_FROM_CHOICE_DISPLAY = 117
  # number of visits having at least goal related to product displayed in a choice display
# (require identifier to be provided with the choice identifier)
# (will only work if a product identifier is provided with the goal)
# if a ReportDimension is on the product id, then only for this product id
# if a ReportDimension is on a Choice, then only for this choice
# if a ReportDimension is on a ChoiceVariant, then only for this choice variant
  VISITS_WITH_GOALS_FROM_CHOICE_DISPLAY = 118
  VALUE_MAP = {1 => "VISITORS", 2 => "VISITS", 3 => "BOUNCES", 4 => "BOUNCE_RATE", 5 => "PAGE_VIEWS", 6 => "PAGE_VIEWS_PER_VISIT", 31 => "TIME_ON_SITE", 7 => "AVERAGE_TIME_ON_SITE", 8 => "PRODUCT_VIEWS", 9 => "PRODUCT_VIEWS_PER_VISIT", 10 => "VISITS_WITH_PRODUCT_VIEWS", 11 => "VISITS_WITH_PRODUCT_VIEWS_RATE", 12 => "SEARCHES", 13 => "SEARCHES_PER_VISIT", 14 => "VISITS_WITH_SEARCHES", 15 => "VISITS_WITH_SEARCHES_RATE", 16 => "GOALS", 17 => "GOALS_PER_VISIT", 18 => "VISITS_WITH_GOALS", 19 => "VISITS_WITH_GOALS_RATE", 20 => "TRANSACTIONS", 21 => "TRANSACTIONS_PER_VISIT", 22 => "VISITS_WITH_TRANSACTIONS", 23 => "VISITS_WITH_TRANSACTIONS_RATE", 28 => "TRANSACTIONS_TURNOVER", 29 => "TRANSACTIONS_PARAMETER_SUM", 30 => "TRANSACTIONS_QUANTITY", 24 => "ADD_TO_BASKETS", 25 => "ADD_TO_BASKETS_PER_VISIT", 26 => "VISITS_WITH_ADD_TO_BASKETS", 27 => "VISITS_WITH_ADD_TO_BASKETS_RATE", 40 => "EVENT_COUNT", 50 => "MAIL_SENT", 51 => "MAIL_OPENED", 52 => "MAIL_CLICKED", 100 => "CHOICE_DISPLAYS", 101 => "VISITS_WITH_CHOICE_DISPLAYS", 110 => "PRODUCT_VIEWS_FROM_CHOICE_DISPLAY", 111 => "VISITS_WITH_PRODUCT_VIEWS_FROM_CHOICE_DISPLAY", 112 => "TRANSACTIONS_FROM_CHOICE_DISPLAY", 113 => "TRANSACTIONS_PARAMETER_SUM_FROM_CHOICE_DISPLAY", 114 => "VISITS_WITH_TRANSACTIONS_FROM_CHOICE_DISPLAY", 115 => "ADD_TO_BASKETS_FROM_CHOICE_DISPLAY", 116 => "VISITS_WITH_ADD_TO_BASKETS_FROM_CHOICE_DISPLAY", 117 => "GOALS_FROM_CHOICE_DISPLAY", 118 => "VISITS_WITH_GOALS_FROM_CHOICE_DISPLAY"}
  VALID_VALUES = Set.new([VISITORS, VISITS, BOUNCES, BOUNCE_RATE, PAGE_VIEWS, PAGE_VIEWS_PER_VISIT, TIME_ON_SITE, AVERAGE_TIME_ON_SITE, PRODUCT_VIEWS, PRODUCT_VIEWS_PER_VISIT, VISITS_WITH_PRODUCT_VIEWS, VISITS_WITH_PRODUCT_VIEWS_RATE, SEARCHES, SEARCHES_PER_VISIT, VISITS_WITH_SEARCHES, VISITS_WITH_SEARCHES_RATE, GOALS, GOALS_PER_VISIT, VISITS_WITH_GOALS, VISITS_WITH_GOALS_RATE, TRANSACTIONS, TRANSACTIONS_PER_VISIT, VISITS_WITH_TRANSACTIONS, VISITS_WITH_TRANSACTIONS_RATE, TRANSACTIONS_TURNOVER, TRANSACTIONS_PARAMETER_SUM, TRANSACTIONS_QUANTITY, ADD_TO_BASKETS, ADD_TO_BASKETS_PER_VISIT, VISITS_WITH_ADD_TO_BASKETS, VISITS_WITH_ADD_TO_BASKETS_RATE, EVENT_COUNT, MAIL_SENT, MAIL_OPENED, MAIL_CLICKED, CHOICE_DISPLAYS, VISITS_WITH_CHOICE_DISPLAYS, PRODUCT_VIEWS_FROM_CHOICE_DISPLAY, VISITS_WITH_PRODUCT_VIEWS_FROM_CHOICE_DISPLAY, TRANSACTIONS_FROM_CHOICE_DISPLAY, TRANSACTIONS_PARAMETER_SUM_FROM_CHOICE_DISPLAY, VISITS_WITH_TRANSACTIONS_FROM_CHOICE_DISPLAY, ADD_TO_BASKETS_FROM_CHOICE_DISPLAY, VISITS_WITH_ADD_TO_BASKETS_FROM_CHOICE_DISPLAY, GOALS_FROM_CHOICE_DISPLAY, VISITS_WITH_GOALS_FROM_CHOICE_DISPLAY]).freeze
end

module ReportDimensionType
  # is the visitor a new visitor or a returning visitor
  NEW_VISITOR = 1
  # the detected country of the visitor (NULL if none detected)
  GEO_COUNTRY = 2
  # the detected zip code of the visitor (NULL if none detected)
  GEO_ZIP = 3
  # the detected subdivision (Kanton for Switzerland) of the visitor (NULL if none detected)
  GEO_SUBDIVISION = 10
  # the detected city of the visitor (NULL if none detected)
  GEO_CITY = 4
  # the user agent name (most common values: IE,Mobile Safari,Chrome,Firefox,Safari,Android browser,Chrome Mobile,Java,IE Mobile,Opera,Mobile Firefox)
  BROWSER_NAME = 11
  # the user agent version
  BROWSER_VERSION = 5
  # the user agent operating system (most common values: Windows 7,iOS 7,Windows 8.1,iOS 8,Android 4.4 KitKat,OS X 10.9 Mavericks,Windows 8,Windows XP,Windows Vista,Android 4.2 Jelly Bean)
  OPERATING_SYSTEM = 6
  # the user agent device category (most common values: Personal computer,Smartphone,Tablet,Other)
  DEVICE_CATEGORY = 7
  # the AdWords Creative (requires that the AdWords ValueTrack is passed on the url parameter as "&creative={creative}"
  ADWORDS_CREATIVE = 8
  # the AdWords Keyword (requires that the AdWords ValueTrack is passed on the url parameter as "&keyword={keyword}"
  ADWORDS_KEYWORD = 9
  # the search queries done in the web-site
  ONSITE_SEARCH_QUERY = 15
  # the different hours of the day (from "0" to "24")
  HOUR_OF_DAY = 20
  # the different moments of the day ("22-6", "6-10", "10-12", "12-14", "14-17", "17-19", "19-22")
  MOMENT_OF_DAY = 21
  # the different days of the week ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
  DAY_OF_WEEK = 22
  # the different moments of the week ("Monday-Friday", "Saturday-Sunday")
  MOMENT_OF_WEEK = 23
  # the timestamp at the beginning of the session (one dimension per session)
  SESSION_START_TIMESTAMP = 24
  # the session id (as provided by the tracker)
  SESSION_ID = 25
  # the session id (internal id of Boxalino)
  INTERNAL_SESSION_ID = 26
  # the visitor id (as provided by the tracker)
  VISITOR_ID = 27
  # the visitor id (internal id of Boxalino)
  INTERNAL_VISITOR_ID = 28
  # the different page view urls
  PAGE_VIEW_URL = 29
  # the different values of a URL parameter (require identifier to be provided with url parameter name)
  URL_PARAMETER = 50
  # the different values of a transaction property (requires identifier to be provided with the transaction property name)
# N.B.: a connection to the transaction property must be available (e.g.: For visit&visitor-based reporting, like BehaviorReport, will only work for the visits/visitors with a transaction)
  TRANSACTION_PROPERTY = 100
  # the different values of a customer property (requires identifier to be provided with the customer property name)
# N.B.: a connection to the transaction property must be available (e.g.: For visit&visitor-based reporting, like BehaviorReport, will only work for the visits/visitors with a login or other ways to link the customer id to the visitor id)
  CUSTOMER_PROPERTY = 150
  # the different values of a product property (requires identifier to be provided with the product property name)
# N.B.: a connection to the transaction property must be available (e.g.: For visit&visitor-based reporting, like BehaviorReport, will only work for the visits/visitors with a product purchased)
  PURCHASED_PRODUCT_PROPERTY = 200
  # the different values of a product property (requires identifier to be provided with the product property name)
# N.B.: a connection to the product property must be available (e.g.: For visit&visitor-based reporting, like BehaviorReport, will only work for the visits/visitors with a product displayed in the choice variant)
  PRODUCT_PROPERTY = 201
  # the different possible choice ids (requires identifier to be provided with the choiceId as indicated in the structure Choice)
# N.B.: a connection to the product property must be available (e.g.: For visit&visitor-based reporting, like BehaviorReport, will only work for the visits/visitors with a product displayed in the choice variant)
  CHOICE = 300
  # the different possible choice variant ids (requires identifier to be provided with the choiceVariantIdId as indicated in the structure ChoiceVariant)
# N.B.: a connection to the product property must be available (e.g.: For visit&visitor-based reporting, like BehaviorReport, will only work for the visits/visitors with a product displayed in the choice variant)
  CHOICE_VARIANT = 301
  #  * The index of the returned time serie (starting at zero) related to this result (requires identifier to be provided with the cohort id field requested)
# * N.B.: the ReportDimensionValue value will indicate the index as a number 0->n-1, n-1 being the last time range of the cohort report
  COHORT_INDEX = 1000
  VALUE_MAP = {1 => "NEW_VISITOR", 2 => "GEO_COUNTRY", 3 => "GEO_ZIP", 10 => "GEO_SUBDIVISION", 4 => "GEO_CITY", 11 => "BROWSER_NAME", 5 => "BROWSER_VERSION", 6 => "OPERATING_SYSTEM", 7 => "DEVICE_CATEGORY", 8 => "ADWORDS_CREATIVE", 9 => "ADWORDS_KEYWORD", 15 => "ONSITE_SEARCH_QUERY", 20 => "HOUR_OF_DAY", 21 => "MOMENT_OF_DAY", 22 => "DAY_OF_WEEK", 23 => "MOMENT_OF_WEEK", 24 => "SESSION_START_TIMESTAMP", 25 => "SESSION_ID", 26 => "INTERNAL_SESSION_ID", 27 => "VISITOR_ID", 28 => "INTERNAL_VISITOR_ID", 29 => "PAGE_VIEW_URL", 50 => "URL_PARAMETER", 100 => "TRANSACTION_PROPERTY", 150 => "CUSTOMER_PROPERTY", 200 => "PURCHASED_PRODUCT_PROPERTY", 201 => "PRODUCT_PROPERTY", 300 => "CHOICE", 301 => "CHOICE_VARIANT", 1000 => "COHORT_INDEX"}
  VALID_VALUES = Set.new([NEW_VISITOR, GEO_COUNTRY, GEO_ZIP, GEO_SUBDIVISION, GEO_CITY, BROWSER_NAME, BROWSER_VERSION, OPERATING_SYSTEM, DEVICE_CATEGORY, ADWORDS_CREATIVE, ADWORDS_KEYWORD, ONSITE_SEARCH_QUERY, HOUR_OF_DAY, MOMENT_OF_DAY, DAY_OF_WEEK, MOMENT_OF_WEEK, SESSION_START_TIMESTAMP, SESSION_ID, INTERNAL_SESSION_ID, VISITOR_ID, INTERNAL_VISITOR_ID, PAGE_VIEW_URL, URL_PARAMETER, TRANSACTION_PROPERTY, CUSTOMER_PROPERTY, PURCHASED_PRODUCT_PROPERTY, PRODUCT_PROPERTY, CHOICE, CHOICE_VARIANT, COHORT_INDEX]).freeze
end

module ConditionOperator
  # when cast as a String, does the substring provided in the ConditionTarget value match exactly the source string?
  IS = 1
  # when cast as a String, does the substring provided in the ConditionTarget value NOT match exactly the source string?
  IS_NOT = 2
  # when cast as a number, is the number provided in the source number greater (but not equal or smaller) than the ConditionTarget value?
  IS_GREATER = 3
  # when cast as a number, is the number provided in the source number greater or equal (but not smaller) than the ConditionTarget value?
  IS_GREATER_OR_EQUAL = 4
  # when cast as a number, is the number provided in the source number smaller (but not equal or greater) than the ConditionTarget value?
  IS_SMALLER = 5
  # when cast as a number, is the number provided in the source number smaller or equal (but not greater) than the ConditionTarget value?
  IS_SMALLER_OR_EQUAL = 6
  # when cast as a String, is the substring provided in the ConditionTarget value contained in the source string?
  CONTAINS = 7
  # when cast as a String, is the substring provided in the ConditionTarget value NOT contained in the source string?
  DOES_NOT_CONTAIN = 8
  # when cast as a String, does the substring provided in the ConditionTarget value match the first characters of the source string?
  STARTS_WITH = 9
  # when cast as a String, does the substring provided in the ConditionTarget value NOT match the first characters of the source string?
  DOES_NOT_START_WITH = 10
  # when cast as a String, does the substring provided in the ConditionTarget value match the last characters of the source string?
  ENDS_WITH = 11
  # when cast as a String, does the substring provided in the ConditionTarget value NOT match the last characters of the source string?
  DOES_NOT_END_WITH = 12
  VALUE_MAP = {1 => "IS", 2 => "IS_NOT", 3 => "IS_GREATER", 4 => "IS_GREATER_OR_EQUAL", 5 => "IS_SMALLER", 6 => "IS_SMALLER_OR_EQUAL", 7 => "CONTAINS", 8 => "DOES_NOT_CONTAIN", 9 => "STARTS_WITH", 10 => "DOES_NOT_START_WITH", 11 => "ENDS_WITH", 12 => "DOES_NOT_END_WITH"}
  VALID_VALUES = Set.new([IS, IS_NOT, IS_GREATER, IS_GREATER_OR_EQUAL, IS_SMALLER, IS_SMALLER_OR_EQUAL, CONTAINS, DOES_NOT_CONTAIN, STARTS_WITH, DOES_NOT_START_WITH, ENDS_WITH, DOES_NOT_END_WITH]).freeze
end

module ReportResultTimeRangeType
  # an absolute time range (defines the datetime start and end of the reporting values for this key)
  REAL_TIME = 1
  # returns the start and end date time based on timestamp 0 being the beginning of the report (if cohort per day: first value: 0->3600*24, second value: 3600*24->3600*24*2, ...)
  COHORT = 2
  VALUE_MAP = {1 => "REAL_TIME", 2 => "COHORT"}
  VALID_VALUES = Set.new([REAL_TIME, COHORT]).freeze
end

# This exception is raised by all the BoxalinoDataIntelligence service function in case of a problem
class DataIntelligenceServiceException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  EXCEPTIONNUMBER = 1
  MESSAGE = 2

  FIELDS = {
    # indicate the exception number based on the enumeration DataIntelligenceServiceExceptionNumber
    EXCEPTIONNUMBER => {:type => ::Thrift::Types::I32, :name => 'exceptionNumber', :enum_class => ::DataIntelligenceServiceExceptionNumber},
    # a textual message to explain the error conditions more in details
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field exceptionNumber is unset!') unless @exceptionNumber
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field message is unset!') unless @message
    unless @exceptionNumber.nil? || ::DataIntelligenceServiceExceptionNumber::VALID_VALUES.include?(@exceptionNumber)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field exceptionNumber!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines the parameters to be send to receive an authentication token (required by all the other services)
class AuthenticationRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ACCOUNT = 1
  USERNAME = 2
  PASSWORD = 3

  FIELDS = {
    # the name of your account (as provided to you by Boxalino team, if you don't have an account, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)
    ACCOUNT => {:type => ::Thrift::Types::STRING, :name => 'account'},
    # usually the same value as account (but can be different for users with smaller rights, if you don't have a username, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)
    USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username'},
    # as provided by Boxalino, or according to the last password update you have set. If you lost your password, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)
    PASSWORD => {:type => ::Thrift::Types::STRING, :name => 'password'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field account is unset!') unless @account
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field username is unset!') unless @username
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field password is unset!') unless @password
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines the authentication object (to pass as authentication proof to all function and services)
class Authentication
  include ::Thrift::Struct, ::Thrift::Struct_Union
  AUTHENTICATIONTOKEN = 1

  FIELDS = {
    # the return authentication token is a string valid for one hour
    AUTHENTICATIONTOKEN => {:type => ::Thrift::Types::STRING, :name => 'authenticationToken'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field authenticationToken is unset!') unless @authenticationToken
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a configuration version of your account. It must be provided to all functions accessing / updating or removing information from your account configuration
class ConfigurationVersion
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CONFIGURATIONVERSIONNUMBER = 1
  SYSTEMPARAMETERS = 2

  FIELDS = {
    # an internal number identifying the configuration version
    CONFIGURATIONVERSIONNUMBER => {:type => ::Thrift::Types::I16, :name => 'configurationVersionNumber'},
    # an internal number identifying the configuration version
    SYSTEMPARAMETERS => {:type => ::Thrift::Types::MAP, :name => 'systemParameters', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field configurationVersionNumber is unset!') unless @configurationVersionNumber
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a configuration difference (somethin which has changed between two configuration versions)
class ConfigurationDifference
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CONTENTTYPE = 1
  CONTENTID = 2
  PARAMETERNAME = 3
  CONTENTSOURCE = 4
  CONTENTDESTINATION = 5

  FIELDS = {
    # the type of content which has changed (e.g.: 'field')
    CONTENTTYPE => {:type => ::Thrift::Types::STRING, :name => 'contentType'},
    # the content id which has changed (e.g: a field id)
    CONTENTID => {:type => ::Thrift::Types::STRING, :name => 'contentId'},
    # the content parameter which has changed (e.g.: a field type)
    PARAMETERNAME => {:type => ::Thrift::Types::STRING, :name => 'parameterName'},
    # the string encoded value of the content parameter value of the source configuration
    CONTENTSOURCE => {:type => ::Thrift::Types::STRING, :name => 'contentSource'},
    # the string encoded value of the content parameter value of the destination configuration
    CONTENTDESTINATION => {:type => ::Thrift::Types::STRING, :name => 'contentDestination'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field contentType is unset!') unless @contentType
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field contentId is unset!') unless @contentId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parameterName is unset!') unless @parameterName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field contentSource is unset!') unless @contentSource
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field contentDestination is unset!') unless @contentDestination
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a data Field. A field covers any type of data property (customer property, product properties, etc.). Fields are global for all data sources, but can be used only for special data sources and ignored for others. This grants that the properties are always ready to unify values from different sources, but they don't have to.
class Field
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FIELDID = 1

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    FIELDID => {:type => ::Thrift::Types::STRING, :name => 'fieldId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fieldId is unset!') unless @fieldId
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a data ProcessTask. A process task covers any kind of process task to be executed by the system.
class ProcessTask
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PROCESSTASKID = 1

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    PROCESSTASKID => {:type => ::Thrift::Types::STRING, :name => 'processTaskId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field processTaskId is unset!') unless @processTaskId
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a data synchronisation process task. It is used to get the data from external systems and process it.
class DataSyncProcessTask
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PROCESSTASKID = 1
  INPUTS = 2
  OUTPUTS = 3
  DEV = 4
  DELTA = 5

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    PROCESSTASKID => {:type => ::Thrift::Types::STRING, :name => 'processTaskId'},
    # list of data sources which should be used to get data from
    INPUTS => {:type => ::Thrift::Types::LIST, :name => 'inputs', :element => {:type => ::Thrift::Types::STRUCT, :class => ::DataSource}},
    # list of data exports which should be used to push the data into
    OUTPUTS => {:type => ::Thrift::Types::LIST, :name => 'outputs', :element => {:type => ::Thrift::Types::STRUCT, :class => ::DataExport}},
    # defines if it is dev version of the task process
    DEV => {:type => ::Thrift::Types::BOOL, :name => 'dev', :default => false},
    # defines if this particular task process is differential
    DELTA => {:type => ::Thrift::Types::BOOL, :name => 'delta', :default => false}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field processTaskId is unset!') unless @processTaskId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field inputs is unset!') unless @inputs
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field outputs is unset!') unless @outputs
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dev is unset!') if @dev.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field delta is unset!') if @delta.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a task Scheduling. A scheduling is a collection of process tasks to be executed one after the other by the system.
class Scheduling
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEDULINGID = 1

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    SCHEDULINGID => {:type => ::Thrift::Types::STRING, :name => 'schedulingId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field schedulingId is unset!') unless @schedulingId
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a task RecommendationBlock. A RecommendationBlock is a visual block of recommendation for one page of your web-site (product detail page, basket page, etc.) you can have several recommendation blocks on the same page.
class RecommendationBlock
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RECOMMENDATIONBLOCKID = 1

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    RECOMMENDATIONBLOCKID => {:type => ::Thrift::Types::STRING, :name => 'recommendationBlockId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field recommendationBlockId is unset!') unless @recommendationBlockId
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a data source. Data source is used to get the data from external systems into DI.
class DataSource
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DATASOURCEID = 1

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    DATASOURCEID => {:type => ::Thrift::Types::STRING, :name => 'dataSourceId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dataSourceId is unset!') unless @dataSourceId
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a data source type used to get the data from reference csv files defined with the API
class ReferenceCSVDataSource
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DATASOURCEID = 1
  EXTENDEDDATASOURCEID = 2

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    DATASOURCEID => {:type => ::Thrift::Types::STRING, :name => 'dataSourceId'},
    # identifier of the data source which will be extended by this data source
    EXTENDEDDATASOURCEID => {:type => ::Thrift::Types::STRING, :name => 'extendedDataSourceId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dataSourceId is unset!') unless @dataSourceId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field extendedDataSourceId is unset!') unless @extendedDataSourceId
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a data export type used to push processed data into
class DataExport
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DATAEXPORTID = 1

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    DATAEXPORTID => {:type => ::Thrift::Types::STRING, :name => 'dataExportId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dataExportId is unset!') unless @dataExportId
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a data EmailCampaign. A campaign is a parameter holder for a campaign execution. It should not change at each sending, but the parameters (especially cmpid) can and should be changed before any new campaign sending (if new campid applies). For the case of trigger campaigns, the cmpid (and other parameters) usually don't change, but for the case of newsletter campaigns, very often each sending has a different id. In this case, the cmpid must be updated (and the dev configuration should be published) every time.
class EmailCampaign
  include ::Thrift::Struct, ::Thrift::Struct_Union
  EMAILCAMPAIGNID = 1
  CMPID = 2
  DATETIME = 3
  BASEURL = 4
  SUBJECT = 5
  FIRSTSENTENCE = 6
  LEGALS = 7

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    EMAILCAMPAIGNID => {:type => ::Thrift::Types::STRING, :name => 'emailCampaignId'},
    # the running campaign id which is often specific to the running of a specific newsletter e-mail (should be changed every time before sending a blast e-mail with the new value (don't forget to publish the dev configuration)
    CMPID => {:type => ::Thrift::Types::STRING, :name => 'cmpid'},
    # the dateTime at which the campaign will be sent (cannot be in the past when the campaign is ran, an exception will be then raised). Must have the format YYYY-MM-DD HH:MM:SS
    DATETIME => {:type => ::Thrift::Types::STRING, :name => 'dateTime'},
    # a localized value of the base url to use for e-mail links
    BASEURL => {:type => ::Thrift::Types::MAP, :name => 'baseUrl', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Language}, :value => {:type => ::Thrift::Types::STRING}},
    # a localized value of the subject line of the e-mail (default, can be overwritten by a specific choice variant localized parameters with parameter name 'subject')
    SUBJECT => {:type => ::Thrift::Types::MAP, :name => 'subject', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Language}, :value => {:type => ::Thrift::Types::STRING}},
    # a localized value of the first sentence of the e-mail (default, can be overwritten by a specific choice variant localized parameters with parameter name 'firstSentence')
    FIRSTSENTENCE => {:type => ::Thrift::Types::MAP, :name => 'firstSentence', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Language}, :value => {:type => ::Thrift::Types::STRING}},
    # a localized value of the legal notices to be included in the e-mail (default, can be extended by a specific choice variant localized parameters with parameter name 'legals')
    LEGALS => {:type => ::Thrift::Types::MAP, :name => 'legals', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Language}, :value => {:type => ::Thrift::Types::STRING}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field emailCampaignId is unset!') unless @emailCampaignId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cmpid is unset!') unless @cmpid
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dateTime is unset!') unless @dateTime
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field baseUrl is unset!') unless @baseUrl
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field subject is unset!') unless @subject
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field firstSentence is unset!') unless @firstSentence
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field legals is unset!') unless @legals
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a data Choice.
class Choice
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CHOICEID = 1

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    CHOICEID => {:type => ::Thrift::Types::STRING, :name => 'choiceId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field choiceId is unset!') unless @choiceId
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a data Choice variant
class ChoiceVariant
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CHOICEVARIANTID = 1
  CHOICEID = 2
  TAGS = 3
  SIMPLEPARAMETERS = 4
  LOCALIZEDPAREMETERS = 5

  FIELDS = {
    # a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
    CHOICEVARIANTID => {:type => ::Thrift::Types::STRING, :name => 'choiceVariantId'},
    # the choice id of the choice which this variant is associated to
    CHOICEID => {:type => ::Thrift::Types::STRING, :name => 'choiceId'},
    # a list of tags this variant is connected to
    TAGS => {:type => ::Thrift::Types::LIST, :name => 'tags', :element => {:type => ::Thrift::Types::STRING}},
    # a list of non-localized parameters this variant is connected to (for example, to overwrite the campaign properties, keys should have the same name as the campaign parameter name)
    SIMPLEPARAMETERS => {:type => ::Thrift::Types::MAP, :name => 'simpleParameters', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRING}}},
    # a list of localized parameters this variant is connected to (for example, to overwrite the campaign properties, keys should have the same name as the campaign parameter name)
    LOCALIZEDPAREMETERS => {:type => ::Thrift::Types::MAP, :name => 'localizedParemeters', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::I32, :enum_class => ::Language}, :value => {:type => ::Thrift::Types::STRING}}}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field choiceVariantId is unset!') unless @choiceVariantId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field choiceId is unset!') unless @choiceId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tags is unset!') unless @tags
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field simpleParameters is unset!') unless @simpleParameters
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field localizedParemeters is unset!') unless @localizedParemeters
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a process task execution status (the status of execution of a process task) with its type and a textual message
class ProcessTaskExecutionStatus
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUSTYPE = 1
  INFORMATION = 2

  FIELDS = {
    # the status type of this execution of the process task
    STATUSTYPE => {:type => ::Thrift::Types::I32, :name => 'statusType', :enum_class => ::ProcessTaskExecutionStatusType},
    # some additonal information about the type (can be empty, used to explain errors and warnings)
    INFORMATION => {:type => ::Thrift::Types::STRING, :name => 'information'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field statusType is unset!') unless @statusType
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field information is unset!') unless @information
    unless @statusType.nil? || ::ProcessTaskExecutionStatusType::VALID_VALUES.include?(@statusType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field statusType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines the execution parameters of a process task
class ProcessTaskExecutionParameters
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PROCESSTASKID = 1
  DEVELOPMENT = 2
  DELTA = 3
  FORCESTART = 4

  FIELDS = {
    # the process task id to execute
    PROCESSTASKID => {:type => ::Thrift::Types::STRING, :name => 'processTaskId'},
    # should the process run with development data that should not to be published into the production environment
    DEVELOPMENT => {:type => ::Thrift::Types::BOOL, :name => 'development'},
    # is the process a differential process that adds or updates a part of the existing data, otherwise the new data will replace any existing data completely
    DELTA => {:type => ::Thrift::Types::BOOL, :name => 'delta'},
    # if another similar process is already running, the forceStart flag will make the new one run, otherwise, the execution will be aborted
    FORCESTART => {:type => ::Thrift::Types::BOOL, :name => 'forceStart'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field processTaskId is unset!') unless @processTaskId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field development is unset!') if @development.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field delta is unset!') if @delta.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field forceStart is unset!') if @forceStart.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a reference CSV file descriptor with the identifier and schema
class ReferenceCSVFileDescriptor
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FILEID = 1
  FILECOLUMNS = 2
  FILEHASH = 3

  FIELDS = {
    # identifier of the csv file, needs to be unique per account
    FILEID => {:type => ::Thrift::Types::STRING, :name => 'fileId'},
    # key-value map of the file columns, where key is a name of the column and value is a column's type
    FILECOLUMNS => {:type => ::Thrift::Types::MAP, :name => 'fileColumns', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32, :enum_class => ::CSVFileColumnType}},
    # internal hash used for csv file upload - this property is set by the API and cannot be changed
    FILEHASH => {:type => ::Thrift::Types::STRING, :name => 'fileHash', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fileId is unset!') unless @fileId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fileColumns is unset!') unless @fileColumns
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a schedulings execution parameters. A scheduling is a collection of process tasks to be executed one after the other by the system.
class SchedulingExecutionParameters
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEDULINGID = 1
  DEVELOPMENT = 2
  DELTA = 3
  FORCESTART = 4

  FIELDS = {
    # the scheduling id to execute
    SCHEDULINGID => {:type => ::Thrift::Types::STRING, :name => 'schedulingId'},
    # should the process tasks run with development version data
    DEVELOPMENT => {:type => ::Thrift::Types::BOOL, :name => 'development'},
    # are the process tasks incremental processes (or full)
    DELTA => {:type => ::Thrift::Types::BOOL, :name => 'delta'},
    # if similar process tasks are already running, the forceStart will make the new ones run, otherwise, the execution will be aborted
    FORCESTART => {:type => ::Thrift::Types::BOOL, :name => 'forceStart'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field schedulingId is unset!') unless @schedulingId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field development is unset!') if @development.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field delta is unset!') if @delta.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field forceStart is unset!') if @forceStart.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a time range
class TimeRange
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FROM = 1
  TO = 2

  FIELDS = {
    # UNIX timestamp of a lower boundary of the range
    FROM => {:type => ::Thrift::Types::I64, :name => 'from'},
    # UNIX timestamp of a upper boundary of the range
    TO => {:type => ::Thrift::Types::I64, :name => 'to'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field from is unset!') unless @from
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field to is unset!') unless @to
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a time range value of the KPI
class TimeRangeValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RANGE = 1
  VALUE = 2

  FIELDS = {
    # used time range
    RANGE => {:type => ::Thrift::Types::STRUCT, :name => 'range', :class => ::TimeRange},
    # KPI value for this particular range
    VALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'value'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field range is unset!') unless @range
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field value is unset!') unless @value
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a report metric (kpi) which can be standard or custom wiht an identifier (e.g.: for goals)
class ReportMetric
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPE = 1
  IDENTIFIER = 2

  FIELDS = {
    # the type of metric
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::ReportMetricType},
    # optional, for the ReportMetricType requiring it (e.g.: goal) the identifier the metric
    IDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'identifier', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    unless @type.nil? || ::ReportMetricType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a report dimension (segmentation) which can be standard or custom with an identifier (e.g.: for url parameters)
class ReportDimension
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPE = 1
  IDENTIFIER = 2
  PARAM1 = 3
  PARAM2 = 4
  PARAM3 = 5

  FIELDS = {
    # the type of metric
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::ReportDimensionType},
    # optional, for the ReportDimensionType requiring it (e.g.: goal) the identifier the metric
    IDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'identifier', :optional => true},
    # optional, an additional parameter
# Use cases:
# - for hierarchical product properties for the type PURCHASED_PRODUCT_PROPERTY (e.g.: "categories") provide the level of depth to consider: "0" : first level, "1" : second level, ...
# in the response, this parameter will be replaced with the category id (label will provide the bread crumb as value : "cat1 >> cat2 >> cat3", but the id of this cat3 will be provided in the param1)
    PARAM1 => {:type => ::Thrift::Types::STRING, :name => 'param1', :optional => true},
    # optional, an additional parameter (planned, but not used until now)
    PARAM2 => {:type => ::Thrift::Types::STRING, :name => 'param2', :optional => true},
    # optional, an additional parameter (planned, but not used until now)
    PARAM3 => {:type => ::Thrift::Types::STRING, :name => 'param3', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    unless @type.nil? || ::ReportDimensionType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# this structure defines the operator and values required for a condition to be true
# (example: condition "is", value : "123"
class ConditionTarget
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATOR = 1
  VALUE = 2

  FIELDS = {
    # the condition target operator ("is", "is not", "greater than", ...)
    OPERATOR => {:type => ::Thrift::Types::I32, :name => 'operator', :enum_class => ::ConditionOperator},
    # the condition value (will be cast in the proper format, so "123" == 123)
    VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operator is unset!') unless @operator
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field value is unset!') unless @value
    unless @operator.nil? || ::ConditionOperator::VALID_VALUES.include?(@operator)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field operator!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# this structure defines a dimension condition, corresponding to a list of ConditionTargets for a given dimension
class DimensionCondition
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DIMENSION = 1
  CONDITIONTARGETS = 2

  FIELDS = {
    # the report dimension
    DIMENSION => {:type => ::Thrift::Types::STRUCT, :name => 'dimension', :class => ::ReportDimension},
    # the list of condition targets to be matched
    CONDITIONTARGETS => {:type => ::Thrift::Types::LIST, :name => 'conditionTargets', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ConditionTarget}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dimension is unset!') unless @dimension
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field conditionTargets is unset!') unless @conditionTargets
  end

  ::Thrift::Struct.generate_accessors self
end

# this structure defines a metric condition, corresponding to a list of ConditionTargets for a given metric
class MetricCondition
  include ::Thrift::Struct, ::Thrift::Struct_Union
  METRIC = 1
  CONDITIONTARGETS = 2

  FIELDS = {
    # the report metric
    METRIC => {:type => ::Thrift::Types::STRUCT, :name => 'metric', :class => ::ReportMetric},
    # the list of condition targets to be matched
    CONDITIONTARGETS => {:type => ::Thrift::Types::LIST, :name => 'conditionTargets', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ConditionTarget}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metric is unset!') unless @metric
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field conditionTargets is unset!') unless @conditionTargets
  end

  ::Thrift::Struct.generate_accessors self
end

# this structure defines a report filter (set of and clauses), all of which must be true
class ReportFilter
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DIMENSIONCONDITIONS = 1
  METRICCONDITIONS = 2

  FIELDS = {
    # the dimension filters
    DIMENSIONCONDITIONS => {:type => ::Thrift::Types::LIST, :name => 'dimensionConditions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::DimensionCondition}},
    # the metric filters
    METRICCONDITIONS => {:type => ::Thrift::Types::LIST, :name => 'metricConditions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::MetricCondition}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dimensionConditions is unset!') unless @dimensionConditions
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metricConditions is unset!') unless @metricConditions
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a metric value association
class ReportMetricValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  METRIC = 1
  VALUE = 2

  FIELDS = {
    # the metric
    METRIC => {:type => ::Thrift::Types::STRUCT, :name => 'metric', :class => ::ReportMetric},
    # the metric value
    VALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'value'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metric is unset!') unless @metric
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field value is unset!') unless @value
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a dimension value association
class ReportDimensionValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DIMENSION = 1
  VALUE = 2

  FIELDS = {
    # the dimension
    DIMENSION => {:type => ::Thrift::Types::STRUCT, :name => 'dimension', :class => ::ReportDimension},
    # the dimension value
    VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dimension is unset!') unless @dimension
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field value is unset!') unless @value
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines one key value set of report results
class ReportResultKeyValues
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RANGE = 1
  VALUES = 2

  FIELDS = {
    # the time range key
    RANGE => {:type => ::Thrift::Types::STRUCT, :name => 'range', :class => ::TimeRange},
    # the metric values for this time range key
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReportMetricValue}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field range is unset!') unless @range
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines the result values (map of metric and values for each requested time ranges)
class ReportResultValues
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPE = 1
  VALUES = 2

  FIELDS = {
    # the type of report result value time ranges
# For each report result groups, the system returns a map of ReportResultValues object (i.e.:a map of report metric (kpi) with their values) for each time range.
# These time ranges can be of different types (absolute defining exactly form a specific moment to another, or relative, starting at 0 for the first key, for cohort analysis).
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::ReportResultTimeRangeType},
    # a map with a key for each time range (each day, each week, each month, ... depending on its meaning provided by the ReportResultTimeRangeType type) providing for each case a map of metric values
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReportResultKeyValues}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
    unless @type.nil? || ::ReportResultTimeRangeType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a transaction report request
class TransactionReportRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  METRICS = 1
  DIMENSIONS = 2
  FILTER = 3
  COHORTIDFIELD = 4
  SORTBYS = 5
  RANGE = 6
  PRECISION = 7
  STARTINDEX = 8
  MAXRESULTS = 9
  IGNOREFILLMISSINGTIMEVALUESWITHZEROS = 10

  FIELDS = {
    # the metrics to evaluate report (e.g.: kpis to return)
    METRICS => {:type => ::Thrift::Types::LIST, :name => 'metrics', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReportMetric}},
    # an optional list of dimensions for the report (for segmentation), while groups are different for each type of reporting, the dimension are normally standard (visitor country, device, ...)
    DIMENSIONS => {:type => ::Thrift::Types::LIST, :name => 'dimensions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReportDimension}, :optional => true},
    # the report filter to use
    FILTER => {:type => ::Thrift::Types::STRUCT, :name => 'filter', :class => ::ReportFilter, :optional => true},
    # optional: ONLY FOR COHORT ANALYSIS, the cohort customer id field (will consider all transactions of customers having this property indicating the customer id to belong to the same cohort)
# E.G.: for re-order rate, indicating the customer id field as the cohort customer id field will work, because each time the same customer re-order, then it is the same cohort re-ordering)
# E.G.: for viral-rate, indicating the customer field which contains the id of the customer who originated the suggestion to buy should be used a cohort customer id field
# N.B: Please consider that cohort analysis are basing the cohort time grouping on the precision TimeRangePrecision variable of the TransactionReportRequest)
    COHORTIDFIELD => {:type => ::Thrift::Types::STRUCT, :name => 'cohortIdField', :class => ::Field, :optional => true},
    # the metrics to use for sorting the results
    SORTBYS => {:type => ::Thrift::Types::LIST, :name => 'sortBys', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReportMetric}, :optional => true},
    # a required date range for the reporting response (precision is only managed per day)
    RANGE => {:type => ::Thrift::Types::STRUCT, :name => 'range', :class => ::TimeRange},
    # a required date range precision if the results should be aggregated per week or month, overall or return for each day
    PRECISION => {:type => ::Thrift::Types::I32, :name => 'precision', :enum_class => ::TimeRangePrecision},
    # an optional starting index (e.g.: if the maximum number of results was exceeded and a second page needs to be displayed). First index is 0.
    STARTINDEX => {:type => ::Thrift::Types::I16, :name => 'startIndex', :optional => true},
    # an required number of maximum number of results (one result is one source of date rage data in of values for all kpis)
    MAXRESULTS => {:type => ::Thrift::Types::I16, :name => 'maxResults'},
    # an optional flag to avoid filling up with zero all possible time precision
    IGNOREFILLMISSINGTIMEVALUESWITHZEROS => {:type => ::Thrift::Types::BOOL, :name => 'ignoreFillMissingTimeValuesWithZeros', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metrics is unset!') unless @metrics
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field range is unset!') unless @range
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field precision is unset!') unless @precision
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field maxResults is unset!') unless @maxResults
    unless @precision.nil? || ::TimeRangePrecision::VALID_VALUES.include?(@precision)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field precision!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a map key (signature) of a transaction report result (indication about what this result is about)
# The TransactionReport object contains a map with the results. For each key (i.e.: result group) the system returns a list of report metrics (kpis) and value for each date range requested.
# These keys are, in the case of a TransactionReport defined by a map of dimension values for each requested Dimension
class TransactionReportResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DIMENSIONVALUES = 1
  VALUES = 2

  FIELDS = {
    # an required map of dimension values
    DIMENSIONVALUES => {:type => ::Thrift::Types::LIST, :name => 'dimensionValues', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReportDimensionValue}},
    # the report result values
    VALUES => {:type => ::Thrift::Types::STRUCT, :name => 'values', :class => ::ReportResultValues}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dimensionValues is unset!') unless @dimensionValues
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a transaction report returned
# This object is specific to TransactionReportRequest but is similar to all other type of report responses, as the only difference usually is the key object of the result variable (in this case: TransactionReportResult)
class TransactionReport
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESULTS = 1
  SUMRESULT = 2

  FIELDS = {
    # the map of reporting results (one result per TransactionReportResult: indicating dimension values)
    RESULTS => {:type => ::Thrift::Types::LIST, :name => 'results', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TransactionReportResult}},
    # the sum result
    SUMRESULT => {:type => ::Thrift::Types::STRUCT, :name => 'sumResult', :class => ::ReportResultValues}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field results is unset!') unless @results
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sumResult is unset!') unless @sumResult
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a behavior report request
class BehaviorReportRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  METRICS = 1
  DIMENSIONS = 2
  FILTER = 3
  SORTBYS = 4
  RANGE = 5
  PRECISION = 6
  STARTINDEX = 7
  MAXRESULTS = 8
  IGNOREFILLMISSINGTIMEVALUESWITHZEROS = 9

  FIELDS = {
    # the metrics to evaluate report (e.g.: kpis to return)
    METRICS => {:type => ::Thrift::Types::LIST, :name => 'metrics', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReportMetric}},
    # an optional list of dimensions for the report (for segmentation), while groups are different for each type of reporting, the dimension are normally standard (visitor country, device, ...)
    DIMENSIONS => {:type => ::Thrift::Types::LIST, :name => 'dimensions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReportDimension}, :optional => true},
    # the report filter to use
    FILTER => {:type => ::Thrift::Types::STRUCT, :name => 'filter', :class => ::ReportFilter, :optional => true},
    # the metrics to use for sorting the results
    SORTBYS => {:type => ::Thrift::Types::LIST, :name => 'sortBys', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReportMetric}, :optional => true},
    # a required date range for the reporting response (precision is only managed per day)
    RANGE => {:type => ::Thrift::Types::STRUCT, :name => 'range', :class => ::TimeRange},
    # a required date range precision if the results should be aggregated per week or month, overall or return for each day
    PRECISION => {:type => ::Thrift::Types::I32, :name => 'precision', :enum_class => ::TimeRangePrecision},
    # an optional starting index (e.g.: if the maximum number of results was exceeded and a second page needs to be displayed). First index is 0.
    STARTINDEX => {:type => ::Thrift::Types::I16, :name => 'startIndex', :optional => true},
    # an required number of maximum number of results (one result is one source of date rage data in of values for all kpis)
    MAXRESULTS => {:type => ::Thrift::Types::I16, :name => 'maxResults'},
    # an optional flag to avoid filling up with zero all possible time precision
    IGNOREFILLMISSINGTIMEVALUESWITHZEROS => {:type => ::Thrift::Types::BOOL, :name => 'ignoreFillMissingTimeValuesWithZeros', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metrics is unset!') unless @metrics
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field range is unset!') unless @range
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field precision is unset!') unless @precision
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field maxResults is unset!') unless @maxResults
    unless @precision.nil? || ::TimeRangePrecision::VALID_VALUES.include?(@precision)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field precision!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a map key (signature) of a behavior report result (indication about what this result is about)
# The BehaviorReport object contains a map with the results. For each key (i.e.: result group) the system returns a list of report metrics (kpis) and value for each date range requested.
# These keys are, in the case of a BehaviorReport defined by a map of dimension values for each requested Dimension
class BehaviorReportResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DIMENSIONVALUES = 1
  VALUES = 2

  FIELDS = {
    # an required map of dimension values
    DIMENSIONVALUES => {:type => ::Thrift::Types::LIST, :name => 'dimensionValues', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReportDimensionValue}},
    # the report result values
    VALUES => {:type => ::Thrift::Types::STRUCT, :name => 'values', :class => ::ReportResultValues}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dimensionValues is unset!') unless @dimensionValues
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
  end

  ::Thrift::Struct.generate_accessors self
end

# This structure defines a behavior report returned
# This object is specific to BehaviorReportRequest but is similar to all other type of report responses, as the only difference usually is the key object of the result variable (in this case: BehaviorReportResult)
class BehaviorReport
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESULTS = 1
  SUMRESULT = 2

  FIELDS = {
    # the map of reporting results (one result per BehaviorReportResult: indicating dimension values)
    RESULTS => {:type => ::Thrift::Types::LIST, :name => 'results', :element => {:type => ::Thrift::Types::STRUCT, :class => ::BehaviorReportResult}},
    # the sum result
    SUMRESULT => {:type => ::Thrift::Types::STRUCT, :name => 'sumResult', :class => ::ReportResultValues}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field results is unset!') unless @results
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sumResult is unset!') unless @sumResult
  end

  ::Thrift::Struct.generate_accessors self
end

